.. include:: def.rst
.. index:: pair: class; io.Pcap
.. _doxid-type_io_pcap:
.. _cid-io.pcap:

class io.Pcap
=============

.. toctree::
	:hidden:

	enum_io_Pcap_Defaults.rst

.. code-block:: jancy
	:class: overview-code-block

	import "io_pcap.jncx"


Overview
~~~~~~~~

This class provides high-level asynchronous interface for the Pcap
(Packet Capture) library. :ref:`More...<details-doxid-type_io_pcap>`

.. _doxid-struct_member_io_pcap_iface_m_snapshotsize:
.. _cid-io.pcap.m_snapshotsize:
.. _doxid-struct_member_io_pcap_iface_m_ispromiscious:
.. _cid-io.pcap.m_ispromiscious:
.. _doxid-struct_member_io_pcap_iface_m_readtimeout:
.. _cid-io.pcap.m_readtimeout:
.. _doxid-struct_member_io_pcap_iface_m_unused:
.. _cid-io.pcap.m_unused:
.. _doxid-struct_member_io_pcap_iface_m_activeevents:
.. _cid-io.pcap.m_activeevents:
.. _doxid-struct_member_io_pcap_iface_m_ioerror:
.. _cid-io.pcap.m_ioerror:
.. _doxid-property_io_pcap_m_readbuffersize:
.. _cid-io.pcap.m_readbuffersize:
.. _doxid-function_io_pcap_wait:
.. _cid-io.pcap.wait:
.. _doxid-function_io_pcap_cancelwait:
.. _cid-io.pcap.cancelwait:
.. _doxid-function_io_pcap_blockingwait:
.. _cid-io.pcap.blockingwait:
.. ref-code-block:: jancy
	:class: overview-code-block

	// enums

	enum :ref:`Defaults<doxid-type_io_pcap_defaults>`

	// fields

	:ref:`size_t<doxid-typedef_size_t>` readonly m_snapshotSize
	bool readonly m_isPromiscious
	:ref:`uint_t<doxid-typedef_uint_t>` readonly m_readTimeout
	char const* readonly :ref:`m_filter<doxid-struct_member_io_pcap_iface_m_filter>`
	:ref:`uint_t<doxid-typedef_uint_t>` readonly m_unused
	:ref:`io.PcapEvents<doxid-type_io_pcapevents>` readonly volatile m_activeEvents
	:ref:`std.Error<doxid-type_std_error>` const* readonly volatile m_ioError
	bool readonly :ref:`m_isOpen<doxid-struct_member_io_pcap_iface_m_isopen>`

	// properties

	:ref:`size_t<doxid-typedef_size_t>` autoget property m_readBufferSize 

	// methods

	bool errorcode :ref:`openDevice<doxid-function_io_pcap_opendevice>` (
	    char const* deviceName,
	    char const* filter,
	    :ref:`uint_t<doxid-typedef_uint_t>` snapshotSize = Defaults . SnapshotSize,
	    bool isPromiscious = Defaults . Promiscious,
	    :ref:`uint_t<doxid-typedef_uint_t>` readTimeout = Defaults . ReadTimeout
	    )

	bool errorcode :ref:`openFile<doxid-function_io_pcap_openfile>` (
	    char const* fileName,
	    char const* filter
	    )

	void :ref:`close<doxid-function_io_pcap_close>` ()
	bool errorcode :ref:`setFilter<doxid-function_io_pcap_setfilter>` (char const* filter)

	:ref:`size_t<doxid-typedef_size_t>` errorcode :ref:`read<doxid-function_io_pcap_read>` (
	    void* p,
	    :ref:`size_t<doxid-typedef_size_t>` size,
	    :ref:`uint64_t<doxid-typedef_uint64_t>`* timestamp = null
	    )

	:ref:`size_t<doxid-typedef_size_t>` errorcode :ref:`write<doxid-function_io_pcap_write>` (
	    void const* p,
	    :ref:`size_t<doxid-typedef_size_t>` size
	    )

	long errorcode wait (
	    :ref:`io.PcapEvents<doxid-type_io_pcapevents>` eventMask,
	    void function* handler (io.PcapEvents triggeredEvents)
	    )

	bool errorcode cancelWait (long handle)

	:ref:`io.PcapEvents<doxid-type_io_pcapevents>` errorcode blockingWait (
	    :ref:`io.PcapEvents<doxid-type_io_pcapevents>` eventMask,
	    :ref:`uint_t<doxid-typedef_uint_t>` timeout
	    )

	// aliases

	alias :ref:`dispose<doxid-alias_io_pcap_dispose>` = close

.. _details-doxid-type_io_pcap:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~

This class provides high-level asynchronous interface for the Pcap
(Packet Capture) library.

Pcap library (called WinPcap on Windows) is de-facto the standard tool for
capturing and injecting low-level network traffic.

A typical sequence of steps when working with ``io.Pcap`` looks something
like this:

* Open a live capture using ``openDevice`` or a capture file (\*.pcap) using
  ``openFile`` method;
* Assign IO event handler with ``wait`` method. You would probably also
  want to *schedule* your event handler to be run in particular
  environment (e.g., in a specific thread) and partially apply some
  syncrhonization ID to discard late events;
* When `io.PcapEvents.IncomingData` event is fired, read packet using
  ``read`` method;
* If you opened a live capture, you can also inject packets with ``write``
  method;
* Close Pcap object when no longer needed with ``close`` method.

Code sample:

.. ref-code-block::

    class MyDialog
    {
        // ...

        io.Pcap m_pcap;
        uint_t m_syncId;

        startCapture (
            char const* device,
            char const* filter = null
            );

        close ();
        waitPcapEvents ();

        onPcapEvent (
            uint_t syncId,
            `io.PcapEvents` triggeredEvents
            );
    }

    MyDialog.startCapture (
        char const* device,
        char const* filter = null
        )
    {
        bool result = try m_pcap.openDevice (device, filter);
        if (!result)
        {
            // handle the error...
        }

        waitPcapEvents ();
    }

    MyDialog.close ()
    {
        m_serial.close ();
        m_syncId++; // events past this point will be discarded as 'late'
    }

    MyDialog.waitPcapEvent ()
    {
        `io.PcapEvents` eventMask =
            `io.PcapEvents.IoError` |
            `io.PcapEvents.IncomingData`;

        m_serial.wait (eventMask, onPcapEvent ~(++m_syncId) @
            g_mainThreadScheduler);
    }

    MyDialog.onPcapEvent (
        uint_t syncId,
        `io.PcapEvents` triggeredEvents
        )
    {
        if (syncId != m_syncId) // late event
            return;

        if (triggeredEvents & `io.PcapEvents.IoError`)
        {
            char cont* errorString = m_pcap.m_ioError.m_description;
            // ...
        }

        if (triggeredEvents & `io.PcapEvents.IncomingData`)
        {
            char buffer [256];
            size_t size = m_pcap.read (buffer, sizeof (buffer));
            // ...
        }

        waitPcapEvents (); // restart wait
    }



.. rubric:: See also:

`io.PcapEvents`

Fields
------

.. _doxid-struct_member_io_pcap_iface_m_filter:
.. _cid-io.pcap.m_filter:
.. ref-code-block:: jancy
	:class: title-code-block

	char const* readonly m_filter

Holds currently specified capture filter [#f4]_.

.. _doxid-struct_member_io_pcap_iface_m_isopen:
.. _cid-io.pcap.m_isopen:
.. ref-code-block:: jancy
	:class: title-code-block

	bool readonly m_isOpen

Holds the open status for the Pcap object, i.e. ``true`` if opened;
``false`` otherwise.

Methods
-------

.. _doxid-function_io_pcap_opendevice:
.. _cid-io.pcap.opendevice:
.. ref-code-block:: jancy
	:class: title-code-block

	bool errorcode openDevice (
	    char const* deviceName,
	    char const* filter,
	    :ref:`uint_t<doxid-typedef_uint_t>` snapshotSize = Defaults . SnapshotSize,
	    bool isPromiscious = Defaults . Promiscious,
	    :ref:`uint_t<doxid-typedef_uint_t>` readTimeout = Defaults . ReadTimeout
	    )

Opens a network interface for Pcap capture.

The function accepts 3 arguments. The first one, ``deviceName``, is
used to specify the device to start capture on. To obtain a list of
available devices, use `io.createPcapDeviceDescList` function.

The second one, ``filter``, allows you to specify a capture filter
[#f4]_ which will be applied to incoming packets -- packets which do
not pass the filter, will never be signalled via
`io.PCapEvents.IncomingData` event and could not be read by ``read``
method.

The third and final parameter specifies whether to put interface in
promiscuous mode.

Returns ``true`` on success. If live capture on specified device could
not be opened, function sets the error reported by Pcap and returns
``false`` [#f1]_.

.. _doxid-function_io_pcap_openfile:
.. _cid-io.pcap.openfile:
.. ref-code-block:: jancy
	:class: title-code-block

	bool errorcode openFile (
	    char const* fileName,
	    char const* filter
	    )

Opens a previously captured \*.pcap file specified by ``fileName``
argument.

The second argument, ``filter``, has the same meaning as in
``openDevice`` method [#f4]_.

Returns ``true`` on success. If capture file could not be opened,
function sets the error reported by Pcap and returns ``false`` [#f1]_.

.. _doxid-function_io_pcap_close:
.. _cid-io.pcap.close:
.. ref-code-block:: jancy
	:class: title-code-block

	void close ()

Closes a previously opened live capture or a capture file, does nothing
if Pcap is not opened. This function always succeeds.

Sometimes it may be convenient to use *disposable* pattern to ensure
timely invokation of ``close`` [#f2]_.

.. _doxid-function_io_pcap_setfilter:
.. _cid-io.pcap.setfilter:
.. ref-code-block:: jancy
	:class: title-code-block

	bool errorcode setFilter (char const* filter)

Allows you to change current capture filter without restarting the
capture.

Returns ``true`` on success. If capture filter could not be changed,
function sets the error reported by Pcap and returns ``false`` [#f1]_.

.. _doxid-function_io_pcap_read:
.. _cid-io.pcap.read:
.. ref-code-block:: jancy
	:class: title-code-block

	:ref:`size_t<doxid-typedef_size_t>` errorcode read (
	    void* p,
	    :ref:`size_t<doxid-typedef_size_t>` size,
	    :ref:`uint64_t<doxid-typedef_uint64_t>`* timestamp = null
	    )

Reads the next packet into the buffer pointed to by ``p`` and ``size``
bytes long.

Returns the actual amount of bytes read or ``-1`` if error occurs.

If read operation is unsuccessful, function sets the error reported by
Pcap and returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler for
``ReadyRead`` event. If this function is called when there are no
incoming pacets, it blocks until either a packet arrives, or Pcap is
closed.

.. _doxid-function_io_pcap_write:
.. _cid-io.pcap.write:
.. ref-code-block:: jancy
	:class: title-code-block

	:ref:`size_t<doxid-typedef_size_t>` errorcode write (
	    void const* p,
	    :ref:`size_t<doxid-typedef_size_t>` size
	    )

Attempts to inject ``size`` bytes from the buffer pointed to by ``p`` as
a packet on a currently opened device.

Returns the actual amount of bytes written on success. If write
operation is unsuccessful, function sets the error reported by Pcap and
returns ``-1`` [#f1]_.

Aliases
-------

.. _doxid-alias_io_pcap_dispose:
.. _cid-io.pcap.dispose:
.. ref-code-block:: jancy
	:class: title-code-block

	alias dispose = close

Effectively makes ``io.Pcap`` a *disposable* class [#f2]_.

---------------------

.. rubric:: Footnotes

.. [#f1]

	|footnote-errorcode|

.. [#f2]

	|footnote-disposable|

.. [#f3]

	|footnote-sync-id|

.. [#f4]

	For detailed description of the syntax used in Pcap capture filter
	expressions refer to: http://www.tcpdump.org/manpages/pcap-filter.7.html

